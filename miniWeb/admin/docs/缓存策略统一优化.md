# 缓存策略统一优化

## 问题分析

### 原始问题
1. **缓存时间冲突**：timeUtils 中定义了2小时缓存，但 Store 中也定义了相同的过期时间
2. **重复逻辑**：BaseStore 已有完整的缓存管理，timeUtils 中重复实现了过期检查
3. **不统一的缓存策略**：各页面使用不同的缓存处理方式

### 设计冲突
- Store 配置：`expireTime: 2 * 60 * 60 * 1000` (2小时)
- BaseStore 内置：`isDataValid()` 方法检查过期
- timeUtils 重复：`isCacheExpired()` 函数重复实现

## 优化方案

### 1. 统一缓存策略
**以 Store 为准**：完全依赖 BaseStore 的缓存管理机制

### 2. 移除重复逻辑
- 删除 timeUtils 中的 `isCacheExpired()` 函数
- 修改 `handleCacheWithTime()` 使用 Store 的 `getData()` 方法
- `getData()` 内部已调用 `isDataValid()` 检查过期

### 3. 优化缓存处理流程
```javascript
// 新的统一流程
const usedCache = await handleCacheWithTime({
  store: myStore,           // Store实例
  fetchData: fetchFunction, // 数据获取函数
  refs: { cachedData, lastUpdateTime }, // Vue refs
  forceRefresh: false       // 是否强制刷新
})
```

## 实现细节

### BaseStore 缓存机制
```javascript
// BaseStore.js 中的缓存检查
isDataValid() {
  if (!this.data || !this.timestamp) return false
  
  const now = Date.now()
  const dataTime = this.timestamp
  
  if (this.options.dayOnly) {
    // 按天检查（Dashboard使用）
    return isSameDay(now, dataTime)
  } else {
    // 按过期时间检查（其他页面使用）
    return (now - dataTime) < this.options.expireTime
  }
}

getData() {
  return this.isDataValid() ? this.data : null
}
```

### 统一的时间工具函数
```javascript
// timeUtils.js 优化后
export const handleCacheWithTime = async ({ store, fetchData, refs, forceRefresh = false }) => {
  const { cachedData, lastUpdateTime } = refs
  
  if (forceRefresh) {
    await fetchData()
    return false
  }

  // 使用Store内置的缓存检查
  const cached = store.getData() // 内部已检查isDataValid()
  const cachedTime = store.getUpdateTime()
  
  if (cached && cachedTime) {
    cachedData.value = cached
    lastUpdateTime.value = formatCachedTime(cachedTime)
    return true
  } else {
    await fetchData()
    return false
  }
}
```

## 各页面缓存配置

### Dashboard (按天缓存)
```javascript
const dashboardStore = new BaseStore('dashboard', {
  dayOnly: true,           // 按天过期
  enablePersist: false,    // 不持久化
})
```

### 其他页面 (2小时缓存)
```javascript
const xxxStore = new BaseStore('xxx', {
  expireTime: 2 * 60 * 60 * 1000,  // 2小时过期
  enablePersist: false,
})
```

## 优化效果

### 1. 消除设计冲突
- ✅ 统一使用 Store 的缓存策略
- ✅ 移除 timeUtils 中的重复逻辑
- ✅ 避免多重过期检查

### 2. 简化代码逻辑
- ✅ 各页面使用统一的 `handleCacheWithTime()` 函数
- ✅ 减少重复的缓存处理代码
- ✅ 统一的时间格式化

### 3. 提升可维护性
- ✅ 缓存策略集中在 Store 配置中
- ✅ 时间相关逻辑统一在 timeUtils 中
- ✅ 清晰的职责分离

## 页面更新状态

### ✅ 已优化页面
1. **ArticleAudit.vue** - 使用统一缓存策略
2. **Dashboard.vue** - 使用统一缓存策略  
3. **UsersAudit.vue** - 导入优化的工具函数
4. **Articles.vue** - 导入优化的工具函数
5. **Invitations.vue** - 导入优化的工具函数
6. **Accounts.vue** - 导入优化的工具函数

### 🔧 核心改进
- 所有页面统一使用 `handleCacheWithTime()` 处理缓存
- 时间显示统一使用 `updatePageTime()` 更新
- 缓存过期完全依赖 Store 的 `isDataValid()` 方法

## 使用示例

### 标准缓存处理
```javascript
// 在页面的数据获取函数中
const loadData = async (forceRefresh = false) => {
  const usedCache = await handleCacheWithTime({
    store: myStore,
    fetchData: async () => {
      // 实际的数据获取逻辑
      const result = await apiCall()
      myData.value = result.data
      myStore.setData(result.data)
      updatePageTime({ lastUpdateTime }, myStore)
    },
    refs: { cachedData: myData, lastUpdateTime },
    forceRefresh
  })
  
  if (usedCache) {
    console.log('使用缓存数据')
  }
}
```

### 刷新按钮处理
```javascript
const handleRefresh = () => {
  loadData(true) // 强制刷新
}
```

## 注意事项

1. **Store 配置为准**：所有缓存时间以 Store 配置为准
2. **不要重复检查**：不要在页面中再次检查缓存过期
3. **统一时间格式**：使用 `updatePageTime()` 确保时间格式一致
4. **错误处理**：缓存处理失败时自动降级到数据刷新

这样的设计确保了缓存策略的一致性和可维护性。